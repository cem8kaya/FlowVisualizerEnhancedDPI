#include "common/crypto_utils.h"

#include <arpa/inet.h>
#include <openssl/aes.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/params.h>

#include <cstring>
#include <vector>

#include "common/logger.h"

namespace callflow {

std::vector<uint8_t> CryptoUtils::aes128ctr(const std::vector<uint8_t>& data,
                                            const std::vector<uint8_t>& key, uint32_t count,
                                            uint8_t bearer, uint8_t direction) {
    if (key.size() != 16) {
        LOG_ERROR("AES-128-CTR requires 16-byte key");
        return {};
    }

    // Construct 128-bit Counter Block (T1)
    // COUNT[0..31] | BEARER[0..4] | DIRECTION[0] | 0...0
    // Standard 3GPP TS 33.401 Annex B.1.3
    // Counter Block T1:
    // Bytes 0-3: COUNT (big endian)
    // Byte 4: (Bearer << 3) | (Direction << 2)
    // Bytes 5-15: 0x00

    uint8_t iv[16] = {0};
    uint32_t count_be = htonl(count);
    std::memcpy(iv, &count_be, 4);

    iv[4] = ((bearer & 0x1F) << 3) | ((direction & 0x01) << 2);
    // Remaining bytes are 0

    // OpenSSL cipher setup
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx)
        return {};

    std::vector<uint8_t> out(data.size());
    int len = 0;

    // We use AES-128-CTR
    // Note: OpenSSL's AES CTR implementation typically treats the IV as the counter block.
    // However, 3GPP CTR mode increments the LAST bits of the counter, but formatted differently?
    // Actually, 3GPP uses standard CTR mode where the counter block is incremented.
    // The Input Counter Block is T1.
    // The keystream is generated by encrypting T1, T1+1, T1+2...
    // OpenSSL handles the increment.

    if (EVP_EncryptInit_ex(ctx, EVP_aes_128_ctr(), nullptr, key.data(), iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }

    if (EVP_EncryptUpdate(ctx, out.data(), &len, data.data(), data.size()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }

    int final_len = 0;
    if (EVP_EncryptFinal_ex(ctx, out.data() + len, &final_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return {};
    }

    EVP_CIPHER_CTX_free(ctx);
    return out;
}

std::vector<uint8_t> CryptoUtils::aes128cmac(const std::vector<uint8_t>& data,
                                             const std::vector<uint8_t>& key, uint32_t count,
                                             uint8_t bearer, uint8_t direction) {
    if (key.size() != 16) {
        LOG_ERROR("AES-128-CMAC requires 16-byte key");
        return {};
    }

    // Construct Message M to sign
    // M = COUNT || BEARER || DIRECTION || 00...00 || MESSAGE
    // COUNT: 4 bytes
    // BEARER: 5 bits
    // DIRECTION: 1 bit
    // 0: 2 bits
    // Total header: 5 bytes? No.
    // TS 33.401, B.2.3:
    // M = COUNT || BEARER || DIRECTION || 0...0 || MESSAGE
    // But actually integrity algorithm input is:
    // COUNT (4 bytes) || Bearer/Dir/0 (1 byte) || MESSAGE
    // Byte 0-3: COUNT
    // Byte 4: (Bearer << 3) | (Direction << 2) & 0xFC ?
    // Check spec.
    // Actually it is:
    // Input = COUNT[0..31] || BEARER[0..4] || DIRECTION[0] || 0..0 || MESSAGE
    // The preamble is typically 8 bytes long in some contexts (PDCP), but for NAS:
    // For NAS (TS 24.301 / TS 33.401):
    // The MAC is calculated over:
    // COUNT (4 bytes) || NAS PDU (excluding MAC/SeqNum? No, usually integrity protects the whole
    // header except MAC) Wait, let's verify NAS integrity input. NAS Integrity protection: MAC =
    // f9(Key, Count, Message) Message = Security Header (excluding MAC) + Payload? The input to
    // NIA2 is: COUNT || MESSAGE But we also need DIRECTION and BEARER. TS 33.501 6.4.3.1: COUNT (32
    // bits) || NAS Message (including sequence number) -> Input to 128-NIA2. BEARER and DIRECTION
    // seem to be part of the IV for Ciphering but not necessarily used for NAS Integrity in the
    // same way? Wait. 128-NIA2 is based on 128-EIA2 (AES-CMAC). Input parameters: COUNT, BEARER,
    // DIRECTION, MESSAGE. How are they concatenated? M = COUNT || BEARER || DIRECTION || 0...0 ||
    // MESSAGE
    //
    // Let's assume standard formatting:
    // 4 bytes COUNT
    // 1 byte: (Bearer << 3) | (Direction << 2)
    // 3 bytes: 0x00 0x00 0x00 (padding? not always)
    //
    // Actually, for NAS, BEARER is constant (0 or 1?). DIRECTION is 0/1.
    // Let's assume a simplified preamble for now:
    // Preamble = COUNT (4 bytes) + 4 bytes of (Bearer/Dir/Padding) ?

    // Correct Reference: TS 33.401 Annex B.2.3
    // M = COUNT[0]..COUNT[31] | BEARER[0]..BEARER[4] | DIRECTION | 0 | 0 | MESSAGE
    // So 32 bits + 5 bits + 1 bit + 2 bits = 40 bits = 5 bytes.
    // Then Message.
    // So Preamble is 5 bytes.

    std::vector<uint8_t> buffer;
    buffer.reserve(4 + 1 + data.size());

    // COUNT
    uint32_t count_be = htonl(count);
    uint8_t* p_count = reinterpret_cast<uint8_t*>(&count_be);
    buffer.insert(buffer.end(), p_count, p_count + 4);

    // Bearer/Dir byte
    uint8_t byte4 = ((bearer & 0x1F) << 3) | ((direction & 0x01) << 2);
    buffer.push_back(byte4);

    // Message
    buffer.insert(buffer.end(), data.begin(), data.end());

    // AES CMAC using OpenSSL 3.0+ EVP_MAC API
    EVP_MAC* mac = EVP_MAC_fetch(nullptr, "CMAC", nullptr);
    if (!mac) {
        return {};
    }

    EVP_MAC_CTX* ctx = EVP_MAC_CTX_new(mac);
    EVP_MAC_free(mac);
    if (!ctx) {
        return {};
    }

    // Set up parameters for CMAC with AES-128
    OSSL_PARAM params[2];
    params[0] = OSSL_PARAM_construct_utf8_string("cipher", const_cast<char*>("AES-128-CBC"), 0);
    params[1] = OSSL_PARAM_construct_end();

    if (!EVP_MAC_init(ctx, key.data(), key.size(), params)) {
        EVP_MAC_CTX_free(ctx);
        return {};
    }

    if (!EVP_MAC_update(ctx, buffer.data(), buffer.size())) {
        EVP_MAC_CTX_free(ctx);
        return {};
    }

    size_t mac_len = 0;
    std::vector<uint8_t> result(16);
    if (!EVP_MAC_final(ctx, result.data(), &mac_len, result.size())) {
        EVP_MAC_CTX_free(ctx);
        return {};
    }

    EVP_MAC_CTX_free(ctx);

    // Truncate to first 4 bytes (NAS MAC is 32-bit)
    result.resize(4);
    return result;
}

std::vector<uint8_t> CryptoUtils::hmacSha256(const std::vector<uint8_t>& key,
                                             const std::vector<uint8_t>& data) {
    unsigned int len = 0;
    std::vector<uint8_t> result(EVP_MAX_MD_SIZE);

    HMAC(EVP_sha256(), key.data(), key.size(), data.data(), data.size(), result.data(), &len);

    result.resize(len);
    return result;
}

}  // namespace callflow
